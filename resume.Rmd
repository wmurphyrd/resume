---
title: "William Murphy, M.S., R.D.N."
output: html_document
css: custom-css.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
library(knitr); library(xtable); library(dplyr); library(ggplot2)

```

```{r contact, results='asis'}
data.frame('william@datatitian.com', "\\(505) 615-2013",
           "http://github.com/wmurphyrd") %>%
  xtable() %>%
  print(type = "html", include.rownames = F, include.colnames = F,
        html.table.attributes = 'border = 1 id = "contact-table"')

```


```{r content, results='asis', fig.height=1.5, fig.width=7, fig.align='center'}
# read in data from a spreadsheet and write it to the document as tables
dat <- read.csv("resume-data.csv", stringsAsFactors = F) %>%
  #read table escapes the newline characters while reading them in, correct
  #this
  mutate(text = gsub("\\n", "\n", text, fixed = T)) %>%
  # preserve ordering of groups by creating factors manually
  mutate_each(funs(factor(., levels = unique(.))), group, subgroup)
writeResumeTable <- function(table) {
  # skip over empty splits created for subgroup-group combos that don't exist
  if(nrow(table) < 1) return()
  # find which subgroup has been passed to write heading to doc and set html
  # id attribute on the table (for css customization)
  subgroup = as.character(table$subgroup[1])
  if(subgroup != "")cat("\n### ", subgroup) else subgroup <- "jobs"
  # There are two types of entries, table-like entries with an optional text
  # description a a year or range of years for the date, and paragraph-like
  # entries with a fully specified date that is used for sorting and not
  # displayed
  if(all(grepl("^\\d+/\\d+/\\d+$", table$date))) {
    table$date <- as.Date(table$date, format = "%m/%d/%Y")
    notEmpty <- names(table)[sapply(table, function(x){
      max(nchar(as.character(x))) > 0
    })]
    table <- table %>% arrange(desc(date)) %>% 
      select_(.dots = notEmpty) %>% select(-date)
  } else {
    srt <- regmatches(table$date, regexpr("\\d{4}", table$date)) %>%
      as.numeric() %>%
      order(decreasing = T)
    table <- table[srt, ]
    # if there are text notes, move them onto their own row (by duplicating rows
    # and deleting extra data). xtable can't do cells that span multiple
    # columns, so we capture the output and add that in manually
    if(max(nchar(table$text)) > 0) {
      table <- table[sort(rep(seq_len(nrow(table)), 2)), ]
      table[seq(1, nrow(table), by = 2), "text"] <- ""
      table[seq(2, nrow(table), by = 2), 
            setdiff(names(table), c("text", "group", "subgroup"))] <- ""
    }
  }
  
  table %>% select(-group, -subgroup, -priority) %>%
    xtable() %>%
    print(type = "html", include.rownames = F, include.colnames = F,
          html.table.attributes = paste0('id = "', gsub(" ", "", subgroup),
                                         '-table" class = "resume-table"'))
}

split(dat, dat$group) %>%
  lapply(function(x){
    summary <- F
    # The priority column can be used to select a few important items from a
    # longer list for display. This allows easy customization for different 
    # opporuntities and for a summary chart of the total numbers of items 
    # not displayed
    if(any(!is.na(x$priority))) {
      allEntries <- x
      x <- filter(x, !is.na(priority) & priority > 0)
      summary <- T
    }
    # ensure some items remain after priority filtering to avoid printing
    # empty section headers
    if(nrow(x)) {
      cat("\n## ", as.character(x$group[1]))
      if(summary) {
        plt <- ggplot(allEntries, aes(x = 1, fill = subgroup)) +
          geom_bar() + 
          # label the count in the middle of each bar
          geom_text(aes(y = cumsum(..count..) - ..count.. / 2, 
                        label = ..count..), stat = "count",
                    size = 10) +
          geom_text(aes(y = cumsum(..count..) - ..count.. / 2,
                        label = subgroup, 
                        x = ifelse(as.integer(subgroup) %% 2 == 0, 
                                   1.75, .25)),
                    stat = "count") +
          geom_segment(aes(y = cumsum(..count..) - ..count.. / 2,
                           yend = cumsum(..count..) - ..count.. / 2,
                           x = ifelse(as.integer(subgroup) %% 2 == 0, 
                                      1.5, .5),
                           xend = ifelse(as.integer(subgroup) %% 2 == 0, 
                                         1.60, .4)),
                       stat = "count") +
          scale_fill_brewer(palette = "BuGn", direction = -1) +
          coord_flip(xlim = c(0.1,1.9)) +
          theme_classic() +
          theme(axis.text = element_blank(), 
                axis.ticks = element_blank(),
                axis.line = element_blank(),
                axis.title = element_blank(),
                legend.position = "none")
        print(plt)
        cat("\n## Selected ", as.character(x$group[1]))
      }
      lapply(split(x, x$subgroup), writeResumeTable)
    }
  }) %>% invisible()
#  dat %>% filter(group == "Training and Education") %>%
#     split(., as.character(.$subgroup)) ->
#     datSplit
# lapply(names(datSplit), function(x) {
#     cat("### ", x)
#     datSplit[[x]] %>% select(-group, -subgroup) %>%
#         xtable() %>%
#         print(type = "html", include.rownames = F, include.colnames = F,
#           html.table.attributes = paste('border = 1 id = "education-table"',
#                                         'class = "resume-table"'))
# }) %>% invisible()
```

