---
title: "William Murphy, M.S., R.D.N."
output: html_document
css: custom-css.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
library(knitr); library(xtable); library(dplyr); library(ggplot2)

```

```{r contact, results='asis'}
data.frame('william@datatitian.com', "\\(505) 615-2013",
           "http://github.com/wmurphyrd") %>%
  xtable() %>%
  print(type = "html", include.rownames = F, include.colnames = F,
        html.table.attributes = 'border = 1 id = "contact-table"')

```


```{r content, results='asis', fig.height=.75, fig.width=7.5, fig.align='center'}
# read in data from a spreadsheet and write it to the document as tables
dat <- read.csv("resume-data.csv", stringsAsFactors = F) %>%
  #read table escapes the newline characters while reading them in, correct
  #this
  mutate_each(funs(gsub("\\n", "\n", ., fixed = T))) %>%
  # preserve ordering of groups by creating factors manually
  mutate_each(funs(factor(., levels = unique(.))), group, subgroup)
writeResumeTable <- function(table) {
  # skip over empty splits created for subgroup-group combos that don't exist
  if(nrow(table) < 1) return()
  # find which subgroup has been passed to write heading to doc and set html
  # id attribute on the table (for css customization)
  subgroup = as.character(table$subgroup[1])
  if(subgroup != "")cat("\n### ", subgroup) else subgroup <- "jobs"
  # There are two types of entries, table-like entries with an optional text
  # description a a year or range of years for the date, and paragraph-like
  # entries with a fully specified date that is used for sorting and not
  # displayed
  if(all(grepl("^\\d+/\\d+/\\d+$", table$date))) {
    table$date <- as.Date(table$date, format = "%m/%d/%Y")
    notEmpty <- names(table)[sapply(table, function(x){
      max(nchar(as.character(x))) > 0
    })] %>% union("subgroup")
    table <- table %>% arrange(desc(date)) %>% 
      select_(.dots = notEmpty) %>% select(-date)
  } else {
    srt <- regmatches(table$date, regexpr("\\d{4}", table$date)) %>%
      as.numeric() %>%
      order(decreasing = T)
    table <- table[srt, ]
    # if there are text notes, move them onto their own row (by duplicating rows
    # and deleting extra data) and have them span the whole table width. xtable 
    # can't do colspans, so we capture its output and add that in manually below
    if(max(nchar(table$text)) > 0) {
      origRows <- seq_len(nrow(table))
      textRows <- which(table$text != "")
      table <- table[c(origRows, textRows), ]
      table[origRows, "text"] <- ""
      table[seq(max(origRows) + 1, nrow(table)), 
            setdiff(names(table), c("text", "group", "subgroup"))] <- ""
      table <- table[order(c(origRows, textRows)), ]
    }
  }
  
  htmlTable <- capture.output(
    table %>% select(-group, -subgroup, -priority) %>%
      xtable() %>%
      print(type = "html", include.rownames = F, include.colnames = F,
            html.table.attributes = paste0('id = "', gsub(" ", "", subgroup),
                                           '-table" class = "resume-table"'))
  )
  # add in the colspan property for rows with nothing but the text field
  htmlTable <- paste(htmlTable, collapse = "\n")
  gsub("(<td>  </td> ){3}<td>(.*?)</td> <td>  </td>",
       "<td colspan = 5>\\2</td>", htmlTable) %>% 
    cat()
  
}

split(dat, dat$group) %>%
  lapply(function(x){
    summary <- F
    # The priority column can be used to select a few important items from a
    # longer list for display. This allows easy customization for different 
    # opporuntities and for a summary chart of the total numbers of items 
    # not displayed
    if(any(!is.na(x$priority))) {
      allEntries <- x
      x <- filter(x, !is.na(priority) & priority > 0)
      summary <- T
    }
    # ensure some items remain after priority filtering to avoid printing
    # empty section headers
    if(nrow(x)) {
      cat("\n## ", as.character(x$group[1]))
      if(summary) {
        plt <- ggplot(allEntries, aes(x = 1, fill = subgroup)) +
          geom_bar() + 
          # label the count in the middle of each bar
          geom_text(aes(y = cumsum(..count..) - ..count.. / 2, 
                        label = ..count..), stat = "count",
                    size = 6) +
          geom_text(aes(y = cumsum(..count..) - ..count.. / 2,
                        label = subgroup, 
                        x = ifelse(as.integer(subgroup) %% 2 == 0, 
                                   1.9, .1)),
                    stat = "count") +
          geom_segment(aes(y = cumsum(..count..) - ..count.. / 2,
                           yend = cumsum(..count..) - ..count.. / 2,
                           x = ifelse(as.integer(subgroup) %% 2 == 0, 
                                      1.45, .55),
                           xend = ifelse(as.integer(subgroup) %% 2 == 0, 
                                         1.65, .35)),
                       stat = "count") +
          scale_fill_brewer(palette = "BuGn", direction = -1) +
          coord_flip(xlim = c(-.15,2)) +
          theme_classic() +
          theme(axis.text = element_blank(), 
                axis.ticks = element_blank(),
                axis.line = element_blank(),
                axis.title = element_blank(),
                legend.position = "none")
        print(plt)
        cat('\n <p id="selected-items">Selected Items:</p>\n')
      }
      lapply(split(x, x$subgroup), writeResumeTable)
    }
  }) %>% invisible()

```
<p id="footer">Created with knitr. Source available at http://github.com/wmurphyrd/resume</p>
